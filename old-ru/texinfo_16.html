<HTML>
<HEAD>
<META HTTP-EQUIV="content-type" content="text/html; charset=windows-1251">
<!-- Created by texi2html 1.57 from /ibend/man/texinfo/html/texinfo.texi on September, 29  1999 -->

<TITLE>Texinfo 4.0 - Команды для определений</TITLE>
</HEAD>
<BODY bgcolor="white" text="black">
 [<A HREF="texinfo_toc.html">Contents</A>] &#160; [<A HREF="texinfo_15.html">Previous</A>] &#160; [<A HREF="texinfo_17.html">Next</A>] &#160;<BR><HR><BR>


<H1><A NAME="sec183">Команды для определений</A></H1>
<P>
<A NAME="idx657"></A>


<P>
Команда <CODE>@deffn</CODE> и другие <EM>команды для определений</EM> позволяют
вам описывать функции, переменные, макросы, команды, пользовательские
параметры, специальные формы и другие объекты в едином формате.


<P>
В Info-файле, определение вызывает появление в начале первой строки
определения категории объекта -- `Функция', `Переменная' или другой, за
которой идет имя объекта и его аргументы.  В печатном руководстве, эта
команда велит TeX печатать имя объекта и его аргументы с левого края,
а название его категории -- с правого.  В обоих выходных форматах для
тела определения делается отступ.  Также, имя объекта вносится в
соответствующий именной указатель: <CODE>@deffn</CODE> вносит имя в указатель
функций, <CODE>@defvr</CODE> в указатель переменных и так далее.


<P>
Руководство не должно и не может содержать более одного определения для
заданного имени.  Приложение, содержащее обзор, должно использовать
<CODE>@table</CODE>, а не команды определений.




<H2><A NAME="sec184">Шаблон определения</A></H2>
<P>
<A NAME="idx658"></A>
<A NAME="idx659"></A>


<P>
Команда <CODE>@deffn</CODE> используется для определений объектов, похожих на
функции.  Чтобы записать определение с помощью <CODE>@deffn</CODE>, напишите
команду <CODE>@deffn</CODE> в начале строки и продолжите строку категорией
объекта, именем объекта и его аргументами (если они есть).  Потом
напишите тело определения на последующих строках.  (Вы можете вставлять
в тело примеры.)  И наконец, завершайте определение командой <CODE>@end
deffn</CODE>, записанной на отдельной строке.  (Другие команды для определений
придерживаются того же формата.)


<P>
Шаблон определения выглядит так:



<PRE>
@deffn <VAR>категория</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...
<VAR>тело-определения</VAR>
@end deffn
</PRE>

<P>
Например,



<PRE>
@deffn Команда forward-word счетчик
Эта команда перемещает точку вперед на столько слов, сколько задано
аргументом @var{счетчик} (или назад, если @var{счетчик}
отрицателен). ...
@end deffn
</PRE>

<P>
дает



<BLOCKQUOTE>
<P>
<DL>
<DT><U>Команда:</U> <B>forward-word</B> <I>счетчик</I>
<DD><A NAME="idx660"></A>
Эта команда перемещает точку вперед на столько слов, сколько задано
аргументом <VAR>счетчик</VAR> (или назад, если <VAR>счетчик</VAR>
отрицателен). ...
</DL>
</BLOCKQUOTE>

<P>
Пишите название категории с заглавной буквы.  Если название категории
содержит пробелы, как, скажем, `Интерактивная команда', заключайте его в
фигурные скобки.  Например:



<PRE>
@deffn {Интерактивная команда} isearch-forward
...
@end deffn
</PRE>

<P>
Иначе второе слово будет ошибочно принято за имя объекта.


<P>
Некоторые команды для определений имеют более общий смысл, чем другие.
Команда <CODE>@deffn</CODE>, например, -- это общая команда для функций и
похожих объектов: для объектов, которые могут принимать аргументы.
Когда вы используете эту команду, вы задаете категорию, к которой
принадлежит данный объект.  Команда <CODE>@deffn</CODE> предлагает три
предопределенных специализированных варианта, <CODE>@defun</CODE>,
<CODE>@defmac</CODE> и <CODE>@defspec</CODE>, которые задают для вас категории
"Функция", "Макро" и "Специальная форма", соответственно.  (В
Лиспе специальной формой называется объект, во многом похожий на
функцию.)  Команда <CODE>@defvr</CODE> также сопровождается несколькими
предопределенными специализированными вариантами для описания конкретных
типов переменных.


<P>
Шаблон для специализированного определения, такого как <CODE>@defun</CODE>,
похож на шаблон общего определения, за исключением того, что вам не
нужно задавать категорию:



<PRE>
@defun <VAR>имя</VAR> <VAR>аргументы</VAR>...
<VAR>тело-определения</VAR>
@end defun
</PRE>

<P>
Таким образом,



<PRE>
@defun buffer-end флаг
Эта функция возвращает @code{(point-min)}, если @var{флаг}
меньше 1, и @code{(point-max)} в противном случае.
...
@end defun
</PRE>

<P>
дает



<BLOCKQUOTE>
<P>
<DL>
<DT><U>Function:</U> <B>buffer-end</B> <I>флаг</I>
<DD><A NAME="idx661"></A>
Эта функция возвращает <CODE>(point-min)</CODE>, если <VAR>флаг</VAR> меньше 1, и
<CODE>(point-max)</CODE> в противном случае. ...
</DL>
</BLOCKQUOTE>

<P>
т рзС зш С  цш  <A HREF="texinfo_16.html#sec195">Пример определения функции</A>, для получения более подробного
примера определения функции, включающего использование <CODE>@example</CODE>
внутри определения.


<P>
Другие специализированные команды работают подобно <CODE>@defun</CODE>.




<H2><A NAME="sec185">Необязательные и повторяющиеся аргументы</A></H2>
<P>
<A NAME="idx662"></A>
<A NAME="idx663"></A>
<A NAME="idx664"></A>
<A NAME="idx665"></A>


<P>
Некоторые объекты принимают необязательные или повторяющиеся аргументы,
которые можно обозначить характерным знаком, использующим квадратные
скобки и многоточие.  Например, специальная форма часто разбивает свой
список аргументов на отдельные аргументы более сложным образом, чем
прямолинейная функция.


<P>
Аргумент, заключенный в квадратные скобки является необязательным.
Таким образом, фраза <SAMP>`<CODE>[<VAR>аргумент</VAR>]</CODE>'</SAMP> означает,
что <VAR>аргумент</VAR> необязателен.  Аргумент, после которого стоит
многоточие, является необязательным и может быть повторен несколько раз.
Таким образом, <SAMP>`<VAR>аргумент</VAR>...'</SAMP> обозначает ноль или более
аргументов.  Круглые скобки используются когда несколько аргументов
сгруппированы в дополнительные уровни структуры списка в языке Лисп.


<P>
Вот, к примеру, строка <CODE>@defspec</CODE> для воображаемой специальной
формы:



<BLOCKQUOTE>
<P>
<DL>
<DT><U>Special Form:</U> <B>foobar</B> <I>(<VAR>var</VAR> [<VAR>from</VAR> <VAR>to</VAR> [<VAR>inc</VAR>]]) <VAR>body</VAR>...</I>
<DD><A NAME="idx666"></A>
</DL>
</BLOCKQUOTE>

<P>
В этом примере аргументы <VAR>from</VAR> и <VAR>to</VAR> являются необязательными,
но должны либо оба присутствовать, либо оба отсутствовать.  Если они
присутствуют, также может быть задан <VAR>inc</VAR>.  Эти аргументы
сгруппированы с аргументом <VAR>var</VAR> в один список, чтобы отличить их от
<VAR>body</VAR>, который включает все остальные элементы формы.


<P>
В исходном Texinfo-файле эта строка <CODE>@defspec</CODE> записана следующим
образом (за исключением того, что он не была разбита на две строки, как
в этом примере).



<PRE>
@defspec foobar (@var{var} [@var{from} @var{to}
     [@var{inc}]]) @var{body}@dots{}
</PRE>

<P>
Эта функция вносится в указатель команд и переменных под именем
<SAMP>`foobar'</SAMP>.




<H2><A NAME="sec186">Две или более "первых" строк</A></H2>
<P>
<A NAME="idx667"></A>
<A NAME="idx668"></A>
<A NAME="idx669"></A>
<A NAME="idx670"></A>


<P>
Чтобы создать две или более `первые' строки, напишите после первой
строки <CODE>@deffn</CODE> строку, начинающуюся с <CODE>@deffnx</CODE>.  Команда
<CODE>@deffnx</CODE> работает в точности, как и <CODE>@deffn</CODE>, но не создает
дополнительный вертикальный пропуск между ней и предыдущей строкой.


<P>
Например,



<PRE>
@deffn {Интерактивная команда} isearch-forward
@deffnx {Интерактивная команда} isearch-backward
Две эти команды аналогичны, за исключением ...
@end deffn
</PRE>

<P>
дает


<P>
<DL>
<DT><U>Интерактивная команда:</U> <B>isearch-forward</B>
<DD><A NAME="idx671"></A>
<DT><U>Интерактивная команда:</U> <B>isearch-backward</B>
<DD><A NAME="idx672"></A>
Две эти команды аналогичны, за исключением ...
</DL>


<P>
Каждая команда для определений имеет форму с `x': <CODE>@defunx</CODE>,
<CODE>@defvrx</CODE>, etc.


<P>
Форма с `x' действует так же, как и <CODE>@itemx</CODE>; смотрите С  цш  <A HREF="texinfo_12.html#sec133"><CODE>@itemx</CODE></A>.




<H2><A NAME="sec187">Команды для определений</A></H2>

<P>
Texinfo предоставляет более дюжины команд для определений; все они
описаны в этом разделе.


<P>
Команды для определений автоматически вносят имя объекта в
соответствующий именной указатель: например, <CODE>@deffn</CODE>,
<CODE>@defun</CODE> и <CODE>@defmac</CODE> вносят имена функций в указатель
функций; <CODE>@defvr</CODE> и <CODE>@defvar</CODE> вносят имена переменных в
указатель переменных.


<P>
Хотя последующие примеры иллюстрируют преимущественно Лисп, эти команды
могут быть использованы и для других языков программирования.




<H3><A NAME="sec188">Функции и похожие объекты</A></H3>

<P>
В этом разделе рассматриваются команды для описания функций и похожих
объектов:


<DL COMPACT>

<DT><CODE>@deffn <VAR>категория</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
<A NAME="idx673"></A>
 
Команда <CODE>@deffn</CODE> -- это общая команда для функций, интерактивных
команд и похожих объектов, которые могут принимать аргументы.  Вы должны
выбрать термин для описания категории, к которой принадлежит
определяемый объект; например, если объект является функцией, то можно
использовать категорию "Функция".  Команда <CODE>@deffn</CODE> записывается
в начале строки, а после нее на той же строке пишутся категория
определяемого объекта, имя объекта и его аргументы, если таковые
имеются.  Завершайте определение с помощью <CODE>@end deffn</CODE> на
отдельной строке.

Например, вот определение:


<PRE>
@deffn Команда forward-char nchars
Переместить точку назад на @var{nchars} символов.
@end deffn
</PRE>

Этот пример показывает довольно сжатое определение "команды",
называемой <CODE>forward-char</CODE>, с одним аргументом, <VAR>nchars</VAR>.

<CODE>@deffn</CODE> печатает имена аргументов, таких как <VAR>nchars</VAR>,
курсивом или заглавными буквами, как при использовании <CODE>@var</CODE>,
потому что мы думаем об этих именах, как о метасинтаксических переменных
--- они обозначают значения действительных аргументов.  Внутри текста
описания, чтобы сослаться на значение аргумента, пишите имя аргумента с
явной командой <CODE>@var</CODE>.  В примере выше мы использовали таким
образом <SAMP>`@var{nchars}'</SAMP>.

Шаблон для <CODE>@deffn</CODE> выглядит так:


<PRE>
@deffn <VAR>категория</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...
<VAR>тело-определения</VAR>
@end deffn
</PRE>

<A NAME="idx674"></A>
<DT><CODE>@defun <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
Команда <CODE>@defun</CODE> -- это команда для определений функций.
<CODE>@defun</CODE> эквивалентна команде <SAMP>`@deffn Функция ...'</SAMP>.

Например,


<PRE>
@defun set символ новое-значение
Изменить значение символа @var{символ} на
@var{новое-значение}.
@end defun
</PRE>

показывает довольно сжатое определение функции <CODE>set</CODE> с аргументами
<VAR>символ</VAR> и <VAR>новое-значение</VAR>.  Имена аргументов в строке
<CODE>@defun</CODE> автоматически выводятся курсивом или заглавными буквами,
как если бы они были заключены в <CODE>@var</CODE>.  Завершайте определение с
помощью <CODE>@end defun</CODE> на отдельной строке.

Шаблон таков:


<PRE>
@defun <VAR>имя-функции</VAR> <VAR>аргументы</VAR>...
<VAR>тело-определения</VAR>
@end defun
</PRE>

<CODE>@defun</CODE> создает вхождение в указателе функций.

<A NAME="idx675"></A>
<DT><CODE>@defmac <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
Команда <CODE>@defmac</CODE> -- это команда для определений макросов.
<CODE>@defmac</CODE> эквивалентна <SAMP>`@deffn Макро ...'</SAMP> и работает
подобно <CODE>@defun</CODE>.

<A NAME="idx676"></A>
<DT><CODE>@defspec <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
Команда <CODE>@defspec</CODE> -- это команда для определений специальных
форм.  (В Лиспе специальной формой называется объект, во многом похожий
на функцию, Т рзС зш С  цш  `Special Forms'   <CITE>GNU Emacs Lisp Reference Manual</CITE>.)  <CODE>@defspec</CODE> эквивалентна <SAMP>`@deffn {Специальная
форма} ...'</SAMP> и работает подобно <CODE>@defun</CODE>.
</DL>



<H3><A NAME="sec189">Переменные и похожие объекты</A></H3>

<P>
Ниже перечислены команды для определений переменных и похожих объектов:


<DL COMPACT>

<DT><CODE>@defvr <VAR>категория</VAR> <VAR>имя</VAR></CODE>
<DD>
<A NAME="idx677"></A>
 
Команда <CODE>@defvr</CODE> -- это общая команда для определений объектов,
схожих с переменными -- объектов, в которых записано значение.  Вы
должны выбрать термин для описания категории определяемого объекта; это
может быть, например, "Переменная", если объект является переменной.
Пишите команду <CODE>@defvr</CODE> в начале строки и, за ней на той же
строке, категорию объекта и его имя.

Пишите название категории с заглавной буквы, как заголовок.  Если
название категории содержит пробелы, как например "Пользовательский
параметр", заключайте его в фигурные скобки.  Иначе второе слово будет
ошибочно принято за имя объекта.  Например,


<PRE>
@defvr {Пользовательский параметр} fill-column
Эта локальная переменная задает максимальную
ширину заполненных строк.
...
@end defvr
</PRE>

Завершайте определение с помощью <CODE>@end defvr</CODE> на отдельной строке.

Шаблон таков:


<PRE>
@defvr <VAR>категория</VAR> <VAR>имя</VAR>
<VAR>тело-определения</VAR>
@end defvr
</PRE>

<CODE>@defvr</CODE> создает для <VAR>имени</VAR> вхождение в указателе переменных.

<A NAME="idx678"></A>
<DT><CODE>@defvar <VAR>имя</VAR></CODE>
<DD>
Команда <CODE>@defvar</CODE> -- это команда для определений переменных.
<CODE>@defvar</CODE> эквивалентна команде <SAMP>`@defvr Переменная ...'</SAMP>.

Например:


<PRE>
@defvar kill-ring
...
@end defvar
</PRE>

Шаблон таков:


<PRE>
@defvar <VAR>имя</VAR>
<VAR>тело-определения</VAR>
@end defvar
</PRE>

<CODE>@defvar</CODE> создает для <VAR>имени</VAR> вхождение в указателе
переменных.

<A NAME="idx679"></A>
<DT><CODE>@defopt <VAR>имя</VAR></CODE>
<DD>
<A NAME="idx680"></A>
Команда <CODE>@defopt</CODE> -- это команда для определений
<EM>пользовательских параметров</EM>, то есть переменных, предназначенных
для изменения пользователем по его вкусу; их много в Emacs
(Т рзС зш С  цш  `Переменные'   <CITE>Руководство по GNU Emacs</CITE>).
<CODE>@defopt</CODE> эквивалентна <SAMP>`@defvr {Пользовательский параметр}
...'</SAMP> и работает подобно <CODE>@defvar</CODE>.
</DL>



<H3><A NAME="sec190">Функции в языках с контролем типов</A></H3>

<P>
Команда <CODE>@deftypefn</CODE> и ее варианты предназначены для описания
функций в языках, в которых вы должны объявлять типы переменных и
функций, таких как Си и Си++.


<DL COMPACT>

<DT><CODE>@deftypefn <VAR>категория</VAR> <VAR>тип-данных</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
<A NAME="idx681"></A>
 
Команда <CODE>@deftypefn</CODE> -- это общая команда для определений функций
и похожих объектов, которые могут принимать аргументы и имеют тип.
Команда <CODE>@deftypefn</CODE> пишется в начале строки, и за ней на той же
строке следуют название категории описываемого объекта, тип
возвращаемого им значения, имя этого объекта и его аргументы, если
таковые имеются.

Например,


<PRE>
@deftypefn {Библиотечная функция} int foobar
   (int @var{foo}, float @var{bar})
...
@end deftypefn
</PRE>

(где текст перед "...", показанный выше как две строки, на самом
деле был бы в настоящем Texinfo-файле на одной строке) дает в Info
следующее:


<PRE>
-- Библиотечная функция: int foobar (int FOO, float BAR)
...
</PRE>

В печатном руководстве, это дает:


<BLOCKQUOTE>
<P>
<DL>
<DT><U>Библиотечная функция:</U> int <B>foobar</B> <I>(int <VAR>foo</VAR>, float <VAR>bar</VAR>)</I>
<DD><A NAME="idx682"></A>
...
</DL>
</BLOCKQUOTE>

Это означает, что <CODE>foobar</CODE> является "библиотечной функцией",
которая возвращает <CODE>int</CODE>, а ее аргументы -- это <VAR>foo</VAR>
(<CODE>int</CODE>) и <VAR>bar</VAR> (<CODE>float</CODE>).

Имена аргументов, которые вы пишете в <CODE>@deftypefn</CODE>, не передаются
неявно <CODE>@var</CODE> -- так как действительные имена аргументов в
<CODE>@deftypefn</CODE> обычно разбросаны между именами типов данных и
ключевыми словами, и Texinfo не может найти их без вашей помощи.  Вместо
этого вы должны явно писать <CODE>@var</CODE> вокруг имен аргументов.  В
примере выше, имена аргументов -- это <SAMP>`foo'</SAMP> и <SAMP>`bar'</SAMP>.

Вот шаблон для <CODE>@deftypefn</CODE>:


<PRE>
@deftypefn <VAR>категория</VAR> <VAR>тип-данных</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR> ...
<VAR>тело-определения</VAR>
@end deftypefn
</PRE>

Заметьте, что если <VAR>категория</VAR> или <VAR>тип-данных</VAR> занимает более
одного слова, они должны быть заключены в фигурные скобки, чтобы стать
одним аргументом.

Если вы описываете процедуру в языке, в котором есть пакеты, таком как
Ада, вам стоит использовать <CODE>@deftypefn</CODE> способом, несколько
противоречащим описанным в предыдущих абзацах соглашениям.

Например:


<PRE>
@deftypefn stacks private push
        (@var{s}:in out stack;
        @var{n}:in integer)
...
@end deftypefn
</PRE>

(Аргументы <CODE>@deftypefn</CODE> показаны разбитыми на три строки, но в
действительном Texinfo-файле должны быть одной строкой.)  В этом случае
процедура классифицируется как принадлежащая к пакету <CODE>stacks</CODE>, а
не как `процедура', и ее тип описывается как <CODE>private</CODE>.  (Имя этой
процедуры <CODE>push</CODE>, а ее аргументы -- это <VAR>s</VAR> и <VAR>n</VAR>.)

<CODE>@deftypefn</CODE> создает для <VAR>имени</VAR> вхождение в указателе
функций.

<DT><CODE>@deftypefun <VAR>тип-данных</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
<A NAME="idx683"></A>
Команда <CODE>@deftypefun</CODE> -- это специализированная команда для
определений функций в языках с контролем типов.  Эта команда
эквивалентна <SAMP>`@deftypefn Функция ...'</SAMP>.

Таким образом,


<PRE>
@deftypefun int foobar (int @var{foo}, float @var{bar})
...
@end deftypefun
</PRE>

дает в Info следующее:


<PRE>
-- Функция: int foobar (int FOO, float BAR)
...
</PRE>

и следующее печатном руководстве:


<BLOCKQUOTE>
<P>
<DL>
<DT><U>Function:</U> int <B>foobar</B> <I>(int <VAR>foo</VAR>, float <VAR>bar</VAR>)</I>
<DD><A NAME="idx684"></A>
...
</DL>
</BLOCKQUOTE>

Вот шаблон:


<PRE>
@deftypefun <VAR>тип</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...
<VAR>тело-определения</VAR>
@end deftypefun
</PRE>

<CODE>@deftypefun</CODE> создает для <VAR>имени</VAR> вхождение в указателе
функций.

</DL>



<H3><A NAME="sec191">Переменные в языках с контролем типов</A></H3>

<P>
Переменные в языках с контролем типов обрабатываются методом, похожим
метод для функций в таких языках.  т рзС зш С  цш  <A HREF="texinfo_16.html#sec190">Функции в языках с контролем типов</A>.  Общая
команда для определений <CODE>@deftypevr</CODE> соответствует
<CODE>@deftypefn</CODE>, а специализированная команда <CODE>@deftypevar</CODE>
соответствует <CODE>@deftypefun</CODE>.


<DL COMPACT>

<DT><CODE>@deftypevr <VAR>категория</VAR> <VAR>тип-данных</VAR> <VAR>имя</VAR></CODE>
<DD>
<A NAME="idx685"></A>
 
Команда <CODE>@deftypevr</CODE> -- это общая команда для определений
объектов, похожих на переменные в языках с контролем типов -- объектов,
в которых записано значение.  Вы должны выбрать термин для описания
категории определяемого объекта; это может быть, например,
"Переменная", если объект является переменной.

Команда <CODE>@deftypevr</CODE> записывается в начале строки, и за ней на той
же строке следуют название категории описываемого объекта, тип данных и
имя этого объекта.

Например:


<PRE>
@deftypevr {Глобальный флаг} int enable
...
@end deftypevr
</PRE>

дает в Info следующее:


<PRE>
-- Глобальный флаг: int enable
...
</PRE>

и следующее в печатном руководстве:


<BLOCKQUOTE>
<P>
<DL>
<DT><U>Глобальный флаг:</U> int <B>enable</B>
<DD><A NAME="idx686"></A>
...
</DL>
</BLOCKQUOTE>

Шаблон такой:


<PRE>
@deftypevr <VAR>категория</VAR> <VAR>тип-данных</VAR> <VAR>имя</VAR>
<VAR>тело-определения</VAR>
@end deftypevr
</PRE>

<CODE>@deftypevr</CODE> создает для <VAR>имени</VAR> вхождение в указателе
переменных.

<A NAME="idx687"></A>
<DT><CODE>@deftypevar <VAR>тип-данных</VAR> <VAR>имя</VAR></CODE>
<DD>
Команда <CODE>@deftypevar</CODE> -- это специализированная команда для
определений переменных в языках с контролем типов.  <CODE>@deftypevar</CODE>
эквивалентна <SAMP>`@deftypevr Переменная ...'</SAMP>.

Например:


<PRE>
@deftypevar int fubar
...
@end deftypevar
</PRE>

дает в Info следующее:


<PRE>
-- Переменная: int fubar
...
</PRE>

и следующее в печатном руководстве:


<BLOCKQUOTE>
<P>
<DL>
<DT><U>Variable:</U> int <B>fubar</B>
<DD><A NAME="idx688"></A>
...
</DL>
</BLOCKQUOTE>

Шаблон такой:


<PRE>
@deftypevar <VAR>тип-данных</VAR> <VAR>имя</VAR>
<VAR>тело-определения</VAR>
@end deftypevar
</PRE>

<CODE>@deftypevar</CODE> создает для <VAR>имени</VAR> вхождение в указателе
переменных.
</DL>



<H3><A NAME="sec192">Объектно-ориентированное программирование</A></H3>

<P>
Здесь приведены команды для форматирования описаний абстрактных
объектов, таких, какие используются в объектно-ориентированном
программировании.  Класс -- это определенный тип абстрактных объектов.
Экземпляр класса -- это конкретный объект, имеющий тип этого класса.
Переменная экземпляра -- это переменная, принадлежащая классу, но
имеющая в каждом экземпляре свое собственное значение.


<P>
В определении, если имя класса на самом деле является именем,
определенным для класса в программной системе, вы должны окружать его
<CODE>@code</CODE>, иначе в печатном руководстве оно будет напечатано шрифтом
для обычного текста.


<DL COMPACT>

<DT><CODE>@defcv <VAR>категория</VAR> <VAR>класс</VAR> <VAR>имя</VAR></CODE>
<DD>
<A NAME="idx689"></A>
 
Команда <CODE>@defcv</CODE> -- это общая команда для определений переменных,
связанных с классами а объектно-ориентированном программировании.  После
команды <CODE>@defcv</CODE> следуют три аргумента: категория определяемого,
класс, к которому оно принадлежит и его имя.  Таким образом,


<PRE>
@defcv {Параметр класса} Window border-pattern
...
@end defcv
</PRE>

показывает, как вы могли бы написать первую строку определения параметра
класса <CODE>border-pattern</CODE> для класса <CODE>Window</CODE>.

Шаблон выглядит так:


<PRE>
@defcv <VAR>категория</VAR> <VAR>класс</VAR> <VAR>имя</VAR>
...
@end defcv
</PRE>

<CODE>@defcv</CODE> создает вхождение в указателе переменных.

<A NAME="idx690"></A>
<DT><CODE>@defivar <VAR>класс</VAR> <VAR>имя</VAR></CODE>
<DD>
Команда <CODE>@defivar</CODE> -- это команда для определений переменных
экземпляров в объектно-ориентированном программировании.
<CODE>@defivar</CODE> эквивалентна <SAMP>`@defcv {Переменная экземпляра}
...'</SAMP>
Шаблон выглядит так:


<PRE>
@defivar <VAR>класс</VAR> <VAR>имя-переменной-экземпляра</VAR>
<VAR>тело-определения</VAR>
@end defivar
</PRE>

<CODE>@defivar</CODE> создает вхождение в указателе переменных.

<A NAME="idx691"></A>
<DT><CODE>@deftypeivar <VAR>класс</VAR> <VAR>тип-данных</VAR> <VAR>имя</VAR></CODE>
<DD>
Команда <CODE>@deftypeivar</CODE> -- это команда для определений
типизированных переменных экземпляра в объектно-ориентированном
программировании.  Она похожа на <CODE>@defivar</CODE>, но добавляет параметр
<VAR>тип-данных</VAR> для указания типа этой переменной экземпляра.
<CODE>@deftypeivar</CODE> создает вхождение в указателе переменных.

<A NAME="idx692"></A>
<DT><CODE>@defop <VAR>категория</VAR> <VAR>класс</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
Команда <CODE>@defop</CODE> -- это общая команда для определений элементов,
которые похожи на методы в объектно-ориентированном программировании.
Такие элементы принимают аргументы, как функции, но связаны с конкретным
классом объектов.

Например, в некоторых системах есть конструкции, называемые
<EM>обертками</EM>, которые связаны с классами, как и методы, но действуют
во многом подобно макросам, а не как функции.  Вы можете использовать
<CODE>@defop Обертка</CODE> для описания одного из них.

Иногда полезно различать методы и <EM>операции</EM>.  Вы можете думать об
операциях, как об описании для метода.  Таким образом, оконная система
может указать, что все классы окон имеют метод, называемый
<CODE>expose</CODE>; вы могли бы сказать, что оконная система определяет
операцию <CODE>expose</CODE> для окон вообще.  Как правило, у операции есть
имя, а также образец аргументов; все методы, реализующие операцию,
должны принимать одинаковые аргументы, так как приложения, использующие
эту операцию, используют ее, не зная, какой метод ее реализует.

Часто более полезным оказывается документировать операции, а не методы.
Например, разработчики оконных приложений должны знать об операции
<CODE>expose</CODE>, но не обязаны быть в курсе, имеет ли данный класс окон
собственный метод для реализации этой операции.  Для описания этой
операции, вы могли бы написать:


<PRE>
@defop Операция windows expose
</PRE>

Команда <CODE>@defop</CODE> записывается в начале строки, и за ней на той же
строке следуют общее название категории операции, имя класса этой
операции, ее имя и аргументы, если таковые имеются.

Вот шаблон:


<PRE>
@defop <VAR>категория</VAR> <VAR>класс</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...
<VAR>тело-определения</VAR>
@end defop
</PRE>

<CODE>@defop</CODE> создает вхождение, такое как `<CODE>expose</CODE> для
<CODE>windows</CODE>', в указателе функций.

<A NAME="idx693"></A>
<DT><CODE>@deftypeop <VAR>категория</VAR> <VAR>класс</VAR> <VAR>тип-данных</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
Команда <CODE>@deftypeop</CODE> -- это команда определения для
типизированных операций в объектно-ориентированном программировании.
Она похожа на <CODE>@defop</CODE>, но в ней лобавлен параметр
<VAR>тип-данных</VAR> для указания типа возвращаемого значения метода.
<CODE>@deftypeop</CODE> создает вхождение в указателе функций.

<DT><CODE>@defmethod <VAR>класс</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
<A NAME="idx694"></A>
Команда <CODE>@defmethod</CODE> -- это команда для определений методов в
объектно-ориентированном программировании.  Метод -- это разновидность
функции, которая реализует операцию для конкретного класса объектов и
его подклассов.  
В Лисп-машине методы на самом деле были функциями, но обычно их
определяли с помощью <CODE>defmethod</CODE>.

<CODE>@defmethod</CODE> эквивалентна <SAMP>`@defop Метод ...'</SAMP>.  Эта
команда записывается в начале строки, и за ней на той же строке следуют
имя класса этого метода, имя этого метода и его аргументы, если таковые
имеются.

Например,


<PRE>
@defmethod <CODE>bar-class</CODE> bar-method argument
...
@end defmethod
</PRE>

показывает определение метода, называемого <CODE>bar-method</CODE>, класса
<CODE>bar-class</CODE>.  Этот метод принимает один аргумент.

Шаблон таков:


<PRE>
@defmethod <VAR>класс</VAR> <VAR>имя-метода</VAR> <VAR>аргументы</VAR>...
<VAR>тело-определения</VAR>
@end defmethod
</PRE>

<CODE>@defmethod</CODE> создает вхождение, такое как `<CODE>bar-method</CODE> для
<CODE>bar-class</CODE>', в указателе функций.

<DT><CODE>@deftypemethod <VAR>класс</VAR> <VAR>тип-данных</VAR> <VAR>имя</VAR> <VAR>аргументы</VAR>...</CODE>
<DD>
<A NAME="idx695"></A>
Команда <CODE>@deftypemethod</CODE> -- это команда для определений методов в
объектно-ориентированных языках с контролем типов, таких как Си++ и
Java.  Она похожа на команду <CODE>@defmethod</CODE>, но в ней добавлен
параметр <VAR>тип-данных</VAR> для задания типа возвращаемого методом
значения.

</DL>



<H3><A NAME="sec193">Типы данных</A></H3>

<P>
Здесь приведены команды для типов данных:


<DL COMPACT>

<DT><CODE>@deftp <VAR>категория</VAR> <VAR>имя</VAR> <VAR>атрибуты</VAR>...</CODE>
<DD>
<A NAME="idx696"></A>
 
Команда <CODE>@deftp</CODE> -- это общая команда для типов данных.  Эта
команда пишется в начале строки, и за ней на той же строке следуют
название категории, имя этого типа данных (слово вроде <CODE>int</CODE> или
<CODE>float</CODE>) и затем имена атрибутов объектов этого типа.  Таким
образом, вы можете использовать эту команду для описания <CODE>int</CODE> или
<CODE>float</CODE>, в этом случае вы могли бы использовать в качестве
категории слова <CODE>тип данных</CODE>.  (Тип данных является категорией
определенных объектов, предназначенной для решения, какие операции можно
с ними производить.)

Например, в Лиспе, <EM>парой</EM> называется некий тип данных, и объект
этого типа имеет два гнезда, называемых CAR и CDR.  Вот как вы
могли бы написать первую строку определения для <CODE>пары</CODE>.


<PRE>
@deftp {Тип данных} пара car cdr
...
@end deftp
</PRE>

Вот шаблон:


<PRE>
@deftp <VAR>категория</VAR> <VAR>имя-типа</VAR> <VAR>атрибуты</VAR>...
<VAR>тело-определения</VAR>
@end deftp
</PRE>

<CODE>@deftp</CODE> создает вхождение в указателе типов данных.
</DL>



<H2><A NAME="sec194">Соглашения по написанию определений</A></H2>
<P>
<A NAME="idx697"></A>
<A NAME="idx698"></A>


<P>
Когда вы пишете определение с использованием <CODE>@deffn</CODE>,
<CODE>@defun</CODE> или одной из других команд для определений, пожалуйста,
используйте аргументы, указывающие свой смысл, как аргумент
<VAR>счетчик</VAR> для функции <CODE>forward-word</CODE>.  Также, если имя
аргумента содержит имя его типа, позаботьтесь, чтобы аргумент в
действительности был этого типа.




<H2><A NAME="sec195">Пример определения функции</A></H2>
<P>
<A NAME="idx699"></A>
<A NAME="idx700"></A>
<A NAME="idx701"></A>
<A NAME="idx702"></A>


<P>
Определение функции использует команды <CODE>@defun</CODE> и <CODE>@end
defun</CODE>.  Имя этой функции следует сразу после команды <CODE>@defun</CODE>, а
за ним на той же строке пишется список параметров.


<P>
Вот определение из С  цш  `Calling Functions'   <CITE>The GNU Emacs Lisp Reference Manual</CITE>.



<BLOCKQUOTE>
<P>
<DL>
<DT><U>Function:</U> <B>apply</B> <I>function &#38;rest arguments</I>
<DD><A NAME="idx703"></A>
<CODE>apply</CODE> calls <VAR>function</VAR> with <VAR>arguments</VAR>, just
like <CODE>funcall</CODE> but with one difference: the last of
<VAR>arguments</VAR> is a list of arguments to give to
<VAR>function</VAR>, rather than a single argument.  We also say
that this list is <EM>appended</EM> to the other arguments.


<P>
<CODE>apply</CODE> returns the result of calling <VAR>function</VAR>.
As with <CODE>funcall</CODE>, <VAR>function</VAR> must either be a Lisp
function or a primitive function; special forms and macros
do not make sense in <CODE>apply</CODE>.



<PRE>
(setq f 'list)
     => list
(apply f 'x 'y 'z)
error--> Wrong type argument: listp, z
(apply '+ 1 2 '(3 4))
     => 10
(apply '+ '(1 2 3 4))
     => 10

(apply 'append '((a b c) nil (x y z) nil))
     => (a b c x y z)
</PRE>

<P>
An interesting example of using <CODE>apply</CODE> is found in the description
of <CODE>mapcar</CODE>.</DL>
</BLOCKQUOTE>

<P>
В исходном Texinfo-файле, этот пример выглядит так::



<PRE>
@defun apply function &#38;rest arguments5F
@code{apply} calls @var{function} with
@var{arguments}, just like @code{funcall} but with one
difference: the last of @var{arguments} is a list of
arguments to give to @var{function}, rather than a single
argument.  We also say that this list is @dfn{appended}
to the other arguments.

@code{apply} returns the result of calling
@var{function}.  As with @code{funcall},
@var{function} must either be a Lisp function or a
primitive function; special forms and macros do not make
sense in @code{apply}.

@example
(setq f 'list)
     @result{} list
(apply f 'x 'y 'z)
@error{} Wrong type argument: listp, z
(apply '+ 1 2 '(3 4))
     @result{} 10
(apply '+ '(1 2 3 4))
     @result{} 10

(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end example

An interesting example of using @code{apply} is found
in the description of @code{mapcar}.@refill
@end defun
</PRE>

<P>
В этом руководстве данная функция перечислена в указателе команд и
переменных под именем <CODE>apply</CODE>.


<P>
Обычные переменные и пользовательские параметры описываются в похожем
формате, за исключением того, что переменные и параметры не принимают
аргументов.
<P></P><HR>
 [<A HREF="texinfo_toc.html">Contents</A>] &#160; [<A HREF="texinfo_15.html">Previous</A>] &#160; [<A HREF="texinfo_17.html">Next</A>] &#160;<BR><HR><BR>

<!-- Rambler Stuff-->
<table Border=0 Width="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"
<tr>
<td ALign=Left vAlign=TOP>
<!--begin of Top100-->
<a href="http://top100.rambler.ru/top100/"><img src="http://counter.rambler.ru/top100.cnt?330202" alt="Rambler's Top100" width=1 height=1 border=0></a>
<!--end of Top100 code-->
</td>
<td ALign="Right" vALIGN=TOP>
<!--begin of Top100 logo-->
<a href="http://top100.rambler.ru/top100/">
<img src="http://top100-images.rambler.ru/top100/banner-88x31-rambler-blue.gif" alt="Rambler's Top100" width=88 height=31 border=0></a>
<!--end of Top100 logo -->
</td>
</tr>
</table>
<!--/Rambler Stuff -->
</body></html>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38951496-1']);
  _gaq.push(['_trackPageview']);
  // st1 Sunday, 06-Dec-2015 19:08:25 MSK
  // st2 109.252.59.207
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
